=====================3=====================

//四类语句：
1.Query language (select) retrieve data
2.Data Manipulation Language (DML) insert, delete and update data
3.Data Definition Language (DDL) define database schemas
4.Data Control Language (DCL) control the access

//desc
desc emp
desc dept
desc salgrade

不敲 ';' 可输入多行指令.

=====================4=====================

//select
select * from salgrade;
select ename, sal*12 from emp;
select 2*3 from dual;
select sysdate from dual;
select ename, sal*12 annual_sal from emp;
--annual_sal 为标注名
select ename, sal*12 “annual sal” from emp;
--用“”时，完全保留格式，包括空格和大小写
select ename||sal from emp;
select ename||'string' from emp;
--||表示紧密连接前后内容
--string内如有'，则用两个'表示

=====================5=====================

//distinct
select distinct deptno from emp;
--只显示每种一个
select distinct deptno, job from emp;
--去除重复的组合，每种组合显示一种一个

=====================6=====================

//where
select * from emp where deptno = 10;
select * from emp where deptno <> 10;
select * from emp where ename = 'CLERK';
select * from emp where ename > 'CBA';
select ename, sal, hiredate from emp where hiredate > '20-Feb-81';

//between/ and/ or
select ename, sal from emp where sal between 800 and 1500;
--必须between 小数 and 大数
select ename, sal from emp where sal >= 800 and sal <= 1500;
select ename, sal, hiredate from emp where deptno = 10 and hiredate > '20-Feb-81';
select ename, sal, hiredate from emp where deptno = 10 or hiredate > '20-Feb-81';

//空值处理
select ename, comm from emp;
select ename, sal*12+comm total_income from emp;
--任何含有空值的表达式，结果均为空值。解决方法见d9
select ename, comm from emp where comm is null;
select ename, comm from emp where comm is not null;

//in
select ename, sal, comm from emp where sal in (800, 1500, 2000);
select ename, sal, comm from emp where sal not in (800, 1500, 2000);
select ename, sal, comm from emp where ename in ('SMITH', 'KING', 'ABC');

//模糊查询 like
select ename from emp where ename like '%ALL%';
--%代表前后可能有0到多个字符
select ename from emp where ename like '_A%';
--_代表一个字符
select ename from emp where ename like '_A\%%';
--如要表示%是个字符，用默认转义字符
select ename from emp where ename like '_A$%%' escape '$';
--自定义$是转义字符.(修改默认的转义字符"\")

=====================7=====================

//order by
select * from dept order by deptno desc;
select * from dept order by deptno asc;
select ename, sal from emp order by sal desc;
select ename, deptno from emp order by deptno asc, ename desc;
--先按照部门升排序，再按照名字降排序

=====================8=====================

select ename, sal*12 annual_sal from emp where ename not like '_A%' and sal>800 order by sal desc;

//常用函数(类似JAVA中的method调用方法)
select lower(ename) from emp;
select upper(ename) from emp;
--ename转成小写大写

select substr(ename,1,3) from emp;
--ename第1个字符开始,取3个字符

select chr(65) from dual;
select ascii('A') from dual;
--字符与ascii转换

select round(23.652) from dual;
select round(23.652, 2) from dual;
select round(23.652, -1) from dual;
--四舍五入=24, 或指定位数=23.65, 四舍五入到十位=20

//to_char 强制格式
select to_char(sal,'$99,999.99') from emp;
--9代表一位数字,该位没有数字就不显示.小数点后强制显示
select to_char(sal,'L99,999.99') from emp;
--L代表本地货币
select to_char(sal,'$00,000.00') from emp;
--0代表一位数字,该位即使没有数字,也需要显示0

select to_char(hiredate,'YYYY-MM-DD HH:MI:SS') from emp;
select to_char(sysdate,'YYYY-MM-DD HH24:MI:SS') from dual;

=====================9=====================

//to_date 强制格式
select ename,hiredate from emp where hiredate > to_date('1981-2-20 12:34:56','YYYY-MM-DD HH24:MI:SS');
--如果直接写 hiredate>'1981-2-20 12:34:56'会出现格式不匹配,要求是日期型

//to_number 强制格式
select sal from emp where sal>to_number('$1.250.00','$9,999,99');

select ename,sal*12 + nvl(comm,0) from emp;
--如果comm中是null值，用0替代返回值

=====================10=====================

//组函数： 变量是多个输入，应变量是单个输出,round, sum, max, min, count

select to_char(avg(sal),'99,999.99') from emp;
--平均工资保留两位小数显示,截去后面无论什么数。需要用to_char
select round(avg(sal),2) from emp;

select sum(sal) from emp;
select max(sal) from emp;
select min(sal) from emp;
select count(comm) from emp;
select count(distinct deptno) from emp;

=====================11=====================

//group by
select deptno, avg(sal) from emp group by deptno;
--以部门为组计算平均值

select deptno, job, max(sal) from emp group by deptno, job order by deptno asc;
--按照deptno和job的组合,计算每种组合的最大值

select ename, sal from emp where sal = (select max(sal) from emp);
--有若干个人都是max(sal)值时,无法用单一输出. 所以不能直接用 select ename, max(sal) from emp; 需要用子查询

select deptno, max(sal) from emp group by deptno;
--每个部门最高工资对应的部门号只有一个,可以用. 每个部门最高工资对应的ename可能不止一个,不能用.ename问题解决方法见d13

=====================12=====================

//having
select deptno, avg(sal) from emp group by deptno having avg(sal)>2000;
--where的过滤是对单条记录进行过滤,对组函数结果不能过滤

//select语句顺序
1 select from
2 where
3 group by
4 having
5 order by

select deptno, avg(sal) from emp
where sal > 1200
group by deptno
having avg(sal) > 1500
order by avg(sal) desc;
--取出工资大于1200的雇员,按部门编号进行分组,取平均工资大于1500的部门,按平均工资降序排列.

quiz:每个部门的平均薪水及其等级 详见d16

=====================13=====================

//子查询
select ename, sal from emp where sal > (select avg(sal) from emp);
--哪些人的工资在公司平均工资之上

//每个部门谁挣的钱最多
select ename from emp where sal = (select max(sal) from emp group by deptno); 
--错误:single-row subquery returns more than one row

select ename from emp where sal in (select max(sal) from emp group by deptno); 
--可执行,但此指令意思为只要工资是这3个值之一即可.对是否同部门比较没有要求

select max(sal) max_sal, deptno from emp group by deptno;
--视为一个表
select ename, sal from emp
join(select max(sal) max_sal, deptno from emp group by deptno) t 
on(emp.sal = t.max_sal and emp.deptno=t.deptno);
--'t'是新的表的名字
--join on 是表连接，相当于where, 详见d15

//ed
--打开编辑器,编辑完保存退出,输入 '/' 重复上一次命令,可执行修改后的指令

=====================14=====================

//求某个人的名字以及他的经理人的名字
select e1.ename, e2.ename from emp e1, emp e2 where e1.mgr = e2.empno;
select e1.ename, e2.ename from emp e1 join emp e2 on ( e1.mgr = e2.empno);
--需要给emp表设定别名e1,e2,以便区分ename分别是来自哪里
--自连接: 为同一张表起不同的别名,当成两张表用

=====================15=====================

//1999连接语法标准
select ename, dname, grade from emp e, dept d, salgrade s
where e.deptno = d.deptno
and e.sal between s.losal and s.hisal
and job<>'CLERK';
select ename, dname from emp, dept where emp.deptno = dept.deptno;
--1992标准,过滤条件job<>'CLERK'和连接条件e.deptno = d.deptno混在一起

select ename, dname from emp join dept on(emp.deptno = dept.deptno);
--1999标准,连接条件放在on里

select ename, dname, grade from emp e
join dept d on(e.deptno = d.deptno)
join salgrade s on(e.sal between s.losal and s.hisal)
where ename not like '_A%';
--每张表连接条件不混在一起,数据过滤条件全部区分开来,清晰一点

select e1.ename, e2.ename from emp e1 join emp e2 on(e1.mgr = e2.emptno);
--新标准求某个人的名字以及他的经理人的名字

//外连接
select e1.ename, e2.ename from emp e1 left outer join emp e2 on(e1.mgr = e2.empno);
--左外连接, emp e1 left join emp e2, 所以e1在left. --left表中条目为准，即使无法连接的数据也显示出来

select ename, dname from emp e right join dept d on(e.deptno  = d.deptno);
--right表中条目为准，即使无法连接的数据也显示出来

select ename, dname from emp e full join dept d on(e.deptno  = d.deptno);
--两表全部条目都列出来

=====================16=====================

select deptno, avg_sal, grade from
(select deptno, avg(sal) avg_sal from emp group by deptno) t
join salgrade s on(t.avg_sal between s.losal and s.hisal);
--每个部门的平均薪水及部门等级

=====================17=====================

//各部门个人的薪水等级平均值
select deptno, avg(grade) avg_grade from 
emp join salgrade s on (sal between s.losal and s.hisal)
group by deptno;

=====================18=====================

//经理人的名字列表
select ename from
emp where empno in (select mgr from emp);

=====================19=====================

//不用组函数求最高薪水值
select distinct sal from emp where sal not in 
(select distinct e1.sal from emp e1 join emp e2 on(e1.sal < e2.sal));
--e1.sal比较e2.sal,最大值无法连接, sal在连接表中取反得到最大值

select sal from (select sal from emp order by sal desc)
where rownum<=1
--Oracle专用

=====================20-21=====================

//平均薪水最高的部门的部门编号
select deptno from 
(select deptno, avg(sal) avg_sal from emp group by deptno)
where avg_sal = (select max(avg(sal)) from emp group by deptno);
--不可 where avg_sal = max(avg(sal)), 同一对象调用两次.需单独调用两次原表格.
--组函数最多嵌套两层

//平均薪水最高的部门的部门名称
select dname from dept where deptno = 
(
	select deptno from 
		(select deptno, avg(sal) avg_sal from emp group by deptno)
	where avg_sal = 
		(select max(avg(sal)) from emp group by deptno)
);
--先求部门编号，再在dept表里找名字

=====================22=====================

//平均薪水等级最低的部门的部门名称
select dname from dept where deptno = 
(
	select deptno from
		(select deptno, avg(sal) avg_sal from emp group by deptno) t
		join salgrade s
		on (t.avg_sal between s.losal and s.hisal)
	where grade = 
		(select min(grade) from 
			(select deptno, avg(sal) avg_sal from emp group by deptno) t 
			join salgrade s 
			on (t.avg_sal between s.losal and s.hisal)
		)
);
--1.求avg_sal对deptno表
--2.连接salgrade表,求deptno对grade表
--3.用grade条件过滤.找min(grade)时需要重复1，2步骤再建一份连表
--4.用deptno找dname

=====================23=====================

//给scott账号创建视图的权限,详见d25b
SQL> show user
USER is "SCOTT"
SQL> conn sys/bjsxt as sysdba;
Connected.
SQL> grant create table, create view to scott;
Grant succeeded.
SQL> conn scott/tiger
Connected.

//视图,就是一张表,一个子查询
create view v$dept_grade as 
	select deptno, grade from
		(select deptno, avg(sal) avg_sal from emp group by deptno) t
		join salgrade s
		on (t.avg_sal between s.losal and s.hisal);

//平均薪水等级最低的部门的部门名称,使用视图
select dname from dept where deptno = 
	(select deptno from v$dept_grade
	where grade = (select min(grade) from v$dept_grade)
	);

=====================24=====================END OF 查询语句 select

//经理工资比普通员工最高工资还要高的名字
select ename, sal from
	(select distinct e1.ename, e1.sal from emp e1, emp e2 where e1.empno = e2.mgr
	)
where sal >
	(select max(sal) from emp where ename not in
		(select distinct e1.ename from emp e1, emp e2 where e1.empno = e2.mgr
		)
	);

=====================25a=====================

// rownum 伪字段(Oracle SQL专用)
select ename,sal from
	(select ename, sal from emp order by sal desc
	)
where rownum<=5;
--薪水最高的五名雇员,先子查询排序后取行号
--rownum只能和 '<', '<=' 连用,不能 '>', '='

select ename, sal from
	(select ename, sal, rownum r from
		(select ename, sal from emp order by sal desc
		)
	)
where r>=6 and r<=10;
--薪水第6到第10名雇员,加一层子查询明示行号后可用 '>', '='


=====================25b=====================START OF DML (Data Manipulation Language)
//4大语句： select, insert, update, delete

//登录超级管理员
conn sys/bjsxt as sysdba;
--只有超级管理员才能创建用户

//删除用户数据
drop user liuchao cascade;

//备份用户数据库
DOS下:
exp
用户名/密码: scott/tiger
一路yes,文件保存在执行exp命令的目录下

//创建新用户
Oracle下:
create user liuchao identified by liuchao default tablespace users quota 10M on users;
--在users表空间上分配10M空间, 用户名/密码都是liuchao

//分配权限
Oracle下:
grant create session, create table, create view to liuchao;

create user 'chou' identified by '1234';
grant all on readmission.* to chou;

//加载用户数据
DOS下:
imp
用户名/密码: liuchao/liuchao
导入的用户名: scott

//取消上一条指令的结果
roll back;

//备份表
create table emp2 as select * from emp;
create table dept2 as select * from dept;
create table salgrade2 as select * from salgrade;
--table和view区别:
table可以insert, delete, update; view只是个查询结果,对数据不能修改
--如何查看有多少table,多少view：详见d32

//insert
insert into dept2 values(50, 'GAME', 'BEIJING');
--加入一条记录,格式需和dept表结构顺序数量一致,deptno, dname, loc
insert into dept2 (deptno, dname) values (60,'GAME2');
--只加入部分数据,需指定字段名/列名
insert into dept2 (select * from dept);
--子查询表的结构要和原表一样

=====================26=====================

quiz:有3个表S, C, SC (多对多关系表设计需遵循三范式,详见d35)
S(SNO, SNAME)代表(学号,姓名)
C(CNO, CNAME, CTEACHER)代表(课号，课名，教师)
SC(SNO, CNO, SCGRADE)代表(学号，课号，成绩)
1. 找出没选过“黎明”老师的所有学生姓名;
2. 列出2门以上(含2门)不及格学生姓名及平时成绩;
3. 既学过1号课程又学过2号课程所有学生的姓名.

1.
select sname from s where sno not in
	(select distinct sno from sc join
		(select cno from c where cteacher = 'LM') t
	on (sc.cno = t.cno)
	);
2.
select sname, avg_score from s join
	(select sno, avg(scgrade) avg_score from sc group by sno having count(scgrade < 60) >= 2) t
on (t.sno = s.sno);
3.
select sname from s where sno in
	(select sno from sc where cno in(1, 2)
	);

//update...set...
update emp2 set sal = sal * 2, ename = ename||'-' where deptno = 10;

//delete
delete from emp2 where dept < 25;

//事物(transaction)
一系列的指令，要么同时完成，要么不完成。类似于synchronized

//一个transaction起始于一条DML语句
update emp2 set sal = sal*2;
delete from dept2;
insert into salgrade values (6, 10000, 20000);

//一个transaction结束于：
1.roll back;
--一个roll back 回滚到第一条DML语句,结束一个transaction
2.commit;
--一个transaction全部指令提交实施,此时roll back也无效了
3.执行了DDL语句,例如create table t (a varchar2(20));
4.执行了DCL语句,例如grant
5.用户正常断开连接，例如exit.直接关窗口,断电不提交

=====================27=====================

//数据类型： 
varchar2 变长字符串,最多可以规定为4K
char 定长字符串
number(p,s) p:共几位, s:小数几位
date
long 变长字符串,最多可以规定为2G

create table stu (
	id number(6),
	name varchar2(20) not null,
	sex number(1),
	age number(3),
	sdate date,
	grade number(2) default 1,
	class number(4),
	email varchar2(50) unique
);
--grade number(2) default 1, 如果没有给grade字段定义数据时，默认值不为空值,为1
--最后一个字段后不需要','

=====================28=====================

//五个约束条件: not null, unique, primary key, foreign key, check

//not null
name varchar2(20) not null,
--不允许name字段为空值输入
insert into stu (id, sex) values (1,0);
--ERROR at line 1:
  ORA-01400: cannot insert NULL into ("SCOTT"."STU"."NAME")

//unique
email varchar2(50) unique
--不允许email字段有重复值,但是允许空值的重复
insert into stu (name, email) values ('name1', 'mail1');
insert into stu (name, email) values ('name2', 'mail1');
--ERROR at line 1:
  ORA-00001: unique constraint (SCOTT.SYS_C005167) violated

//表级约束
create table stu(
	id number(6) primary key,
	name varchar2(20) constraint stu_name_nn not null,
	sex number(1),
	age number(3),
	sdate date,
	grade number(2) default 1,
	class number(4),
	email varchar2(50),
	constraint stu_name_email_uni unique(email,name)
);
--name varchar2(20) constraint stu_name_nn not null, 给name字段不能为空值的字段级约束起一个代号stu_name_nn
--constraint stu_name_email_uni unique(email,name) 给表约束条件起个代号(必须起);sname和email的组合不能重复

=====================29=====================

//primary key 标识一条惟一记录
--email是unique,但是允许重复的空值;且其为string类,不如id的数字类速度快
--从语法上来说,主键相当于not null和unique的组合
--另一种表级写法: constraint stu_id_pk primary key (id),
--也可以用两个字段的组合作为primary key: constraint stu_id_pk primary key (id, name),

//foreign key
建立在一张表的两个字段上,或是两个表的两个字段上.一个字段的值参考另一个字段的值.
例如往emp表中insert一条记录时候,不能输入deptno字段为50,因为在dept表中没用定义50这个deptno

create table stu(
	id number(6) primary key,
	name varchar2(20) not null,
	sex number(1),
	age number(3),
	sdate date,
	grade number(2) default 1,
	class number(4) constraint stu_class_fk references class(id),
	email varchar2(50),
	constraint stu_name_email_uni unique(email,name)
);
create table class (
	id number(4) primary key,
	name varchar2(20) not null
);
--class number(4) references class(id),输入stu条目时，class number必须符合class中的id字符段中有的值
--被参考的字段必须是 primary key
--另一种表级写法： constraint stu_class_fk foreign key (class) references class(id),

insert into stu(id, name, class, email) values (1, 'a', 1000, 'a');
--ERROR at line 1:
  ORA-02291: integrity constraint (stu_class_fk) violated - parent key not found
insert into class values(1000, 'c1');
insert into stu(id, name, class, email) values (1, 'a', 1000, 'a');

delete from class where id = 1000;
--ERROR at line 1:
  ORA-02292: integrity constraint (stu_class_fk) violated - child record found

=====================30=====================

2 quiz

=====================31=====================

//修改现有表的结构 alter
alter table stu add(addr varchar2(100));
alter table stu drop(addr);
alter table stu modify(addr varchar2(50));
--如果已有一条addr数据长度大于希望修改值,则不能操作

//修改现有表的约束条件
delete from class;
--ERROR at line 1:
  ORA-02292: integrity constraint (stu_class_fk) violated - child record found
--可看到到约束条件的名字,所以建表时给constraint起个代号比较好
--找约束条件的名字: select constraint_name, table_name from user_constraints;
alter table stu drop constraint stu_class_fk;
delete from class;
--现在可删
alter table stu add constraint stu_class_fk foreign key (class) references class (id)；

=====================32=====================

//数据字典表
select table_name from user_tables;
--列出当前用户下有多少张表
select view_name from user_views;
--列出当前用户下有多少个视图
select constraint_name, table_name from user_constraints;
--列出当前用户下有多少个约束条件

//查询表名
select table_name from dictionary where table_name like 'USER%' order by table_name;

=====================33=====================

//index
create index index_stu_email on stu (email);
drop index index_stu_email;
select index_name from user_indexes;
--给表添加unique或primary key constraint时,系统会自动添加一个索引
--拥有索引的字段的读效率会更高.但写入数据时还需额外修改索引,效率反而低了

//view
视图就是一个起了名字的子查询
表结构修改后,相应视图也需要修改,增加了维护的难度
一般不更改视图中的数据

=====================34=====================

//sequence (Oracle SQL专用)
用来产生一个唯一的不间断的数字序列,一般用来做主键
create table article(
	id number,
	title varchar2(1024),
	content long
);
create sequence seq;
insert into article values(seq.nextval,'title','conent');
insert into article values(seq.nextval,'title','conent');

//控制sequence
alter sequence seq minvalue 1;
alter sequence seq maxvalue 1000;
alter sequence seq start with 10;
alter sequence seq increment by 1;
drop sequence seq;

=====================35=====================

//三范式
范式:数据库设计所遵循的规则,追求不存在冗余数据(同样的数据不存第二遍)

第一范式的第一个要求:要有主键
第一范式的第二个要求:列不可分(已是最小元素)

第二范式:当一张表里用组合字段作为主键的时候,非主键的字段只与字段组合有关联(不依赖于部分主键)
例如studentid,course组合为主键,可放grade与studentid,course的组合相关联.
而此时如果放studentname仅与studentid相关联,则不合适,需单独建表

第三范式:一个表中不包含已在其它表中已包含的非主键信息

=====================36=====================

//设计表满足bbs项目需求
1.分板块,板块里有帖子
2.帖子有回复,树状的回复结构,后面的可以回复前面任何一个回复
3.只有注册的用户才能发表帖子
4.每一个板块有一个版主,版主有各种权限

=====================37=====================

table user
userid(PK)
username
password

table thread
postid(PK)
userid(PK)
content

table category
postid(PK)
category
adminid (FK) user(userid)

=====================38=====================

#PL-SQL: procedure language - sequential quary language
固定4大语句块：
1．declear: 变量的申明
2．begin: 从什么地方开始执行程序
3．exception: catch到exception时执行的程序
4．end;: 结束程序

//begin...end
set serveroutput on;
begin
	dbms_output.put_line('HelloWorld');
end;
/
--set serveroutput on;默认不显示运算结果,需手动打开

=====================39=====================

//declear
declare
	v_name varchar2(20);
begin
	v_name := 'myname';
	dbms_output.put_line(v_name);
end;
/
--":="是pascal语句赋值方法,':'和'='必须合在一起

//exception
declare
	v_num number := 0;
begin
	v_num := 2 / v_num;
	dbms_output.put_line(v_num);
exception
	when others then
	dbms_output.put_line('error');
end;
/

=====================40=====================

//变量申明的规则
1.变量名不能够使用保留字,如from,select,推荐格式v_vname
2.第一个字符必须是字母
3.变量名最多包含30个字符
4.不能与数据库的表或者列同名
5.每一行只能申明一个变量

//常用简单变量类型
1.binary_integer:整数,主要用来计数和数组下标而不是用来表示字段类型
2.number:数字类型,包含整数和小数
3.char:定长字符串
4.vachar2:变长字符串
5.date:日期
6.long:长字符串,最长2GB
7.boolean:布尔类型,可以取值为true,false和null值,一定要给初值

declare
	v_temp number(1);
	v_count binary_integer := 0;
	v_sal number(7,2) := 4000.00;
	v_date date := sysdate;
	v_pi constant number(3,2) := 3.14;
	v_valid boolean := false;
	v_name varchar2(20) not null := 'MyName';
begin
	dbms_output.put_line('v_temp value:'|| v_temp);
end;
--v_pi constant number(3,2) := 3.14; constant相当于java中final
--v_name varchar2(20) not null := 'MyName'; 一样的constraint语法
--dbms_output.put_line('v_temp value:'|| v_temp); 不能打印boolean类型值

//注释
注释一行: --line
注释多行: /* ... */

//使用%type自动随原始表字段变量类型变化而改变this变量类型
declare
	v_empno number(4);
	v_empno2 emp.empno%type;
	v_empno3 v_empno2%type;
begin
	dbms_output.put_line('test');
end;
/

=====================41=====================

//复合变量
1. table: 相当于Java 里的array
2. record: 相当于Java 里的class

declare
	type type_table_emp_empno is table of emp.empno%type index by binary_integer;
	v_empnos type_table_emp_empno;
begin
	v_empnos(0) := 7369;
	v_empnos(2) := 7839;
	v_empnos(-1) := 9999;
	dbms_output.put_line(v_empnos(-1));
end;
/

--type关键字定义一种新的table变量类型,变量名字是type_table_emp_empno,这个名字代表table里装的是emp表中的empno类型变量
--index by binary_integer说明数组下标是binary_integer基础类型,固定写法
--v_empnos type_table_emp_empno;指定v_empnos是type_table_emp_empno类型变量
--v_empnos(-1) := 9999; Oracle中下标可为负值,此处定义(-1)元素值为9999

=====================42=====================

declare
	type type_record_dept is record(
		deptno dept.deptno%type,
		dname dept.dname%type,
		loc dept.loc%type
	);
	v_temp type_record_dept;
begin
	v_temp.deptno := 50;
	v_temp.dname := 'aaaa';
	v_temp.loc := 'bj';
	dbms_output.put_line(v_temp.deptno||' '||v_temp.dname);
end;
/
--type关键字定义一种新的record变量类型,该record变量含有若干field

//使用%rowtype申明record变量：表结构变化时,变量结构也随之变化
declare
	v_temp dept%rowtype;
begin
	v_temp.deptno := 50;
	v_temp.dname := 'aaaa';
	v_temp.loc := 'bj';
	dbms_output.put_line(v_temp.deptno||' '||v_temp.dname);
end;
/
--

=====================43=====================

//PL-SQL中使用select...into...
Select语句必须返回一条记录,否则这个指令没有意义
同时由于接收结果变量的限制,有且只能有一条记录

declare
	v_ename emp.ename%type;
	v_sal emp.sal%type;
begin
	select ename, sal into v_ename, v_sal from emp where empno=7369;
	dbms_output.put_line(v_ename || ' ' || v_sal);
end;
/
--select ename, sal into v_ename, v_sal from emp where empno=7369;将ename, sal取出放入v_ename, v_sal变量中
--不可写select ename, sal into v_ename, v_sal from emp where deptno = 10;变量无法储存多个结果

declare
	v_emp emp%rowtype;
begin
	select * into v_emp from emp where empno = 7369;
	dbms_output.put_line(v_emp.ename);
end;
/
--存一条记录

//PL-SQL中使用insert...into...
declare
	v_deptno dept.deptno%type := 50;
	v_dname dept.dname%type := 'aaaa';
	v_loc dept.loc%type := 'bj';
begin
	insert into dept2 values(v_deptno, v_dname, v_loc);
	commit;
end;
/

declare
	v_deptno emp2.deptno%type := 10;
	v_count number;
begin
	update emp2 set sal =sal/2 where deptno =v_deptno;
	select deptno into v_deptno from emp2 where empno=7369;
	select count(*) into v_count from emp2;
	dbms_output.put_line(sql%rowcount || ' observations changed');
	commit;
end;
/
--sql%rowcount返回一个update指令改变了几条记录
--三条指令结果分别影响了：3条，1条，1条

=====================44=====================

//PL-SQL中使用DDL语句
begin
	execute immediate 'create table T (nnn varchar2(20) default ''aaa'')';
end;
/
--固定用法:execute immediate 'DDL'
--''aaa'':用两个'防止和外面的'冲突

//if语句
取出7369的薪水:如果<1200,则输出'low';如果<2000,则输出'middle';否则'high'
declare
	v_sal emp.sal%type;
begin
	select sal into v_sal from emp where empno=7369;
	if(v_sal<1200) then
		dbms_output.put_line('low');
	elsif(v_sal <2000) then
		dbms_output.put_line('middle');
	else
		dbms_output.put_line('high');
	end if;
end;
/
--注意:elsif(v_sal <2000)中的elsif写法,不是elseif,也不是else if
--注意:最后一个else后面不加then,其他都要加then
--end if; 最后有一个';'

=====================45=====================

//loop语句
declare
	i binary_integer := 1;
begin
	loop
		dbms_output.put_line(i);
		i := i + 1;
		exit when (i >= 11);
	end loop;
end;
/

declare
	j binary_integer := 1;
begin
	while j < 11 loop
		dbms_output.put_line(j);
		j := j + 1;
	end loop;
end;
/

begin
	for k in 1..10 loop
		dbms_output.put_line(k);
	end loop;
	
	for k in reverse 1..10 loop
		dbms_output.put_line(k);
	end loop;	
end;
/
--相当于增强型循环，不常用

=====================46=====================

//异常处理
declare
	v_temp number(4);
begin
	select empno into v_temp from emp where deptno = 10;
	dbms_output.put_line(v_temp);
exception
	when too_many_rows then
		dbms_output.put_line('too many rows error');
	when no_data_found then
		dbms_output.put_line('no data found error');
	when others then
		dbms_output.put_line('unkonwn error');
end;
/
--此例中如果deptno = 10返回结果只有一个empno,程序还能无exception运行

//常用dba记录错误方法
create table errorlog(
	id number primary key,
	errcode number,
	errmsg varchar2(1024),
	errdate date
);

create sequence sequence_seq_errolog_id start with 1 increment by 1;

declare
	v_deptno dept.deptno%type := 70;
	v_errcode number;
	v_errmsg varchar2(1024);
begin
	delete from dept where deptno = v_deptno;
	commit;
exception
	when others then
		rollback;
		v_errcode := SQLCODE;
		v_errmsg := SQLERRM;
		insert into errorlog values (sequence_seq_errolog_id.nextval, v_errcode, v_errmsg, sysdate);
		commit;
end;
/

select to_char(errdate,'YYYY-MM-DD HH24:MI:SS') from errorlog;

=====================47=====================

//cursor 游标(重点,用以遍历)
declare
	cursor c is select * from emp;
	v_emp c%rowtype;
begin
	open c;
		loop
			fetch c into v_emp;
			exit when (c%notfound);
			dbms_output.put_line(v_emp.ename);
		end loop;
	close c;
end;
/
--cursor c is select * from emp; 此时不会真正读取数据,在open时候才开始占用内存
--fetch c into v_emp;取游标的第一个值传给v_emp,下一个循环fetch时候,c自动累加一格
--cursor找不到下一个对象时,返回c%notfound,同时c的值不变

//cursor四个属性: isopen, notfound, found, rowcount

=====================48=====================

declare
	cursor c is select * from emp;
begin
	for v_emp in c loop
		dbms_output.put_line(v_emp.ename);
	end loop;
end;
/
--自动open,close,fetch

//带参数的cursor
declare
	cursor c(v_deptno emp.deptno%type, v_job emp.job%type) is select ename, sal from emp where deptno = v_deptno and job = v_job;
begin
	for v_temp in c(30,'CLERK') loop
		dbms_output.put_line(v_temp.ename);
	end loop;
end;
/

//可更新的cursor
declare
	cursor c is select * from emp2 for update;
begin
	for v_temp in c loop
		if (v_temp.sal < 2000) then
			update emp2 set sal = sal*2 where current of c;
		elsif (v_temp.sal = 5000) then
			delete from emp2 where current of c;
		end if;
	end loop;
	commit;
end;
/
--cursor c is select * from emp2 for update;需要说明是为了update用
--update...where current of c;当前cursor在哪条记录上就更改哪条记录
--v_temp.sal = 5000 赋值用":=",逻辑比较用'='

=====================49=====================

//stored procedure
create or replace procedure p is
	cursor c is	select * from emp2 for update;
	begin
		for v_emp in c loop
			if(v_emp.deptno=10) then
				update emp2 set sal=sal+10 where current of c;
			elsif(v_emp.deptno=20) then
				update emp2 set sal=sal+20 where current of c;
			else
				update emp2 set sal=sal+50 where current of c;
			end if;
		end loop;
		commit;
	end;
/
--创建存储过程,不是执行了过程

//执行方法
execute p;
--方法1
begin
	p;
end;
/
--方法2

//stored procedure
create or replace procedure p (v_a in number,v_b number,v_ret out number, v_temp in out number) is
	begin
		if(v_a > v_b) then
			v_ret := v_a;
		else
			v_ret := v_b;
		end if;
		v_temp := v_temp + 1;
	end;
/
--in是传入参数:调用这个变量时需赋值
--没有in,out时,默认是in类型
--out是传出参数:将结果传出到调用过程(相当于Java中的return)
--in out代表即可传入也可传出

//执行方法
declare
	v_a number := 3;
	v_b number := 4;
	v_ret number;
	v_temp number := 5;
begin
	p(v_a, v_b, v_ret, v_temp);
	dbms_output.put_line(v_ret);
	dbms_output.put_line(v_temp);
end;
/
--如果程序有错,系统只会提示有错,具体错误需要输入:show error;

=====================50=====================

//删除一个procedure
drop procedure p;

//stored function
create or replace function sal_tax (v_sal number) return number is
	begin
		if(v_sal < 2000) then
			return 0.10;
		elsif(v_sal < 2750) then
			return 0.15;
		else
			return 0.20;
		end if;
	end;
/
--不谈政治 01-Mar-2007
--使用方法同组函数:select lower(ename), sal_tax(sal) from emp;

//trigger 触发器
create table emp2_log(
	uname varchar2(20),
	action varchar2(10),
	atime date
);

create or replace trigger trig after insert or delete or update on emp2 for each row
	begin
		if inserting then
			insert into emp2_log values (USER, 'insert', sysdate);
		elsif updating then
			insert into emp2_log values (USER, 'update', sysdate);
		elsif deleting then
			insert into emp2_log values (USER, 'delete', sysdate);
		end if;
	end;
/
--trigger必须依附在某一张表上,这里是emp2表
--after关键字也可替换成before
--for each row代表记录一个指令对每条记录的影响.如没有这个关键字,则按次记录

=====================51=====================

//利用触发器修改引用约束(万不得已才可以用)
create or replace trigger trig after update on dept for each row
	begin
		update emp set deptno = :NEW.deptno where deptno = :OLD.deptno;
	end;
/
--:NEW.deptno是在update后的状态,:OLD.deptno是之前的状态

update dept set deptno = 99 where deptno = 10;
--此时由于deptno在emp中被引用的每一条都修改成99了,所以dept.deptno可以修改

=====================52=====================

//树状结构展示
drop table article;
create table article(
	id number primary key,
	cont varchar2(4000),
	pid number,
	isleaf number(1),
	alevel number(2)
);
--isleaf number(1),该节点下面不再有子节点了就是叶子节点(1),如果有子节点(0)
--alevel number(2) 该节点的级别
--id和pid已经可以构成树状结构了,但是使用不是很方便,需要冗余字段isleaf,alevel

insert into article values (1, '蚂蚁大战大象', 0, 0, 0);
insert into article values (2, '大象被打趴下了', 1, 0, 1);
insert into article values (3, '蚂蚁也不好过', 2, 1, 2);
insert into article values (4, '瞎说', 2, 0, 2);
insert into article values (5, '没有瞎说', 4, 1, 3);
insert into article values (6, '怎么可能', 1, 0, 1);
insert into article values (7, '怎么没有可能', 6, 1, 2);
insert into article values (8, '可能性是很大的', 6, 1, 2);
insert into article values (9, '大象进医院了', 2, 0, 2);
insert into article values (10, '护士是蚂蚁', 9, 1, 3);
commit;
--要求结果如下:
	1	2	3	4
1	蚂蚁大战大象
2		大象被打趴下了
3			蚂蚁也不好过
4			瞎说
5			没有瞎说
6		怎么可能
7			怎么没有可能
8			可能性是很大的
9			大象进医院了
10				护士是蚂蚁

=====================53=====================

create or replace procedure p (v_pid article.pid%type) is
	cursor c is select * from article where pid = v_pid;
	begin
		for v_article in c loop
			dbms_output.put_line(v_article.cont);
			p(v_article.id);
		end loop;
	end;
/

//也可以利用isleaf提高效率
create or replace procedure p (v_pid article.pid%type) is
	cursor c is select * from article where pid = v_pid;
	begin
		for v_article in c loop
			dbms_output.put_line(v_article.cont);
			if(v_article.isleaf = 0) then
				p(v_article.id);
			end if;
		end loop;
	end;
/

//执行procedure
exec p(0);

//利用v_level产生缩进
create or replace procedure p (v_pid article.pid%type, v_level binary_integer) is
	cursor c is select * from article where pid = v_pid;
	v_preStr varchar2(1024) := ' ';
	begin
		for i in 1..v_level loop
			v_preStr := v_preStr || '>>>';
		end loop;
		
		for v_article in c loop
			dbms_output.put_line(v_preStr || v_article.cont);
			if(v_article.isleaf = 0) then
				p(v_article.id, v_level + 1);
			end if;
		end loop;
	end;
/

exec p(0, 0);

quiz:展现emp表的树状结构:经理管着员工



set password = password("new_password");